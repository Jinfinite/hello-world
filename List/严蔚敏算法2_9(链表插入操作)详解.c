	/*插入操作只要链表存在就可以执行，而不用考虑链表是否为空表。*/
Status ListInsert_L(LinkList *L, int i, ElemType e){
	p = L; j = 0;
	/*
	由于执行插入操作时，需要找到所插入位置的前一个位置。（方便操作）
	当插入的位置为链表的第一个位置时候，此时p应该指向头结点，所以p的初始值为L;
	头节点是所谓的第0个元素，即j的值为0
	*/
	
	
	/*从第0个元素开始找第i-1个元素，则循环的次数为i-1。j为循环变量，j的初值为0。
	则循环终止条件为j<i-1（j<=i-2，循环次数为i-2 - 0 + 1 = i-1）
	由于p指向是将要插入的位置的前一个位置，所要要保证p不能为空。
	p不空向后移动，找到第i-1个元素。
	*/
	while(p && j<i-1){
		p = p->next;
		++j;
	}
	/*
	一、上述循环体如果被执行了最后退出了有两种情况
	1.p的值为空；此时说明没有找到第i个元素，即所给的i值大于表长+1（i值不合法）
	2.j的值等于i-1了，此时说明找到了第i-1个元素。
	二、上顺循环体如果没有被执行则
	2.j的值大于或等于i-1，当j的值大于i-1时，这说明i的值是小于1的，则说明i的值不合法。
		当j的值等于i-1时候（此时i等于1），相当于（一）中的第2点，说明找到了第i-1个元素。
		即第头结点。
	*/
	
	
	/*下列的if语句如果执行了，说明了i的值不合法。
	1.p为空，说明i的值大于表长加1；
	2.j>i-1,说明i的值小于1.
	*/
	if(!p || j>i-1)
		return ERROR;
		
	/*
	当函数执行将要执行下一条语句时，说明第i-1个值是存在的。
	则现在p指向的就是第i-1个元素，现在就可以进行相应的操作了。
	*/
	s = (LinkList)malloc(sizeof(LNode));
	if(!s)
		exit(OVERFLOW);
	s->data = e;
	s->next = p->next;
	p->next = s;
	return OK;
}

