Status ListDelete_L(LinkList *L, int i, ElemType *e){
	/*
	由于执行删除操作时，需要找到所删除节点的前一个节点的位置。（方便操作）
	当删除的节点为链表的第一个节点时候，此时p应该指向头结点，所以p的初始值为L;
	头节点是所谓的第0个元素，即j的值为0
	*/
	p = L; j = 0;
	
	
	/*
	从第0个元素开始找第i-1个元素，则循环的次数为i-1。j为循环变量，j的初值为0。
	则循环终止条件为j<i-1（j<=i-2，循环次数为i-2 - 0 + 1 = i-1）
	由于p->next是将要删除的元素，所要要保证p->next不能为空。
	当p->next不空,p向后移动，找到第i-1个元素。
	*/
	while(p->next && j<i-1){
		p = p->next;
		++j;
	}
	/*
	一、上述循环体如果被执行了最后退出了有两种情况
	1.p->next的值为空；此时说明没有找到第i-1个元素，所给的i值大于表长（i值不合法）
	2.j的值等于i-1了，此时说明找到了第i-1个元素。
	二、上顺循环体如果没有被执行则
	1.链表为空链表，则p->next为空。
	2.j的值大于或等于i-1，当j的值大于i-1时，这说明i的值是小于1的，则说明i的值不合法。
		当j的值等于i-1时候（此时i等于1），相当于（一）中的第2点，说明找到了第i-1个元素。
		即头结点。
	*/
	
	/*
	当函数执行将要执行下一条语句时，说明第i-1个值是存在的。
	则现在p指向的就是第i-1个元素，现在就可以进行相应的操作了。
	*/
	if(!p->next || j>i-1)
		return ERROR;
	s = p->next;
	p->next = s->next;
	*e = s->data;
	free(s);
	return OK;
}