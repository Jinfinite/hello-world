	/*
	由于链表的长度信息一般是隐含的，所以在进行查找，插入删除等操作时，
	就没法像顺序表那样在算法的开头的地方就进行查找，删除，插入的位置的合法性的判断
	基本操作为：使指针p始终指向第j个数据元素
	*/

Status GetElem_L(LinkList L,int i,ElemType *e){
	//由于是取链表中的有效元素，所以p一开始指向链表的第一个有效元素。
	p = L->next; j = 1;
	
	/*
	从第1个元素开始找第i个元素，则循环的次数为i-1。j为循环变量，j的初值为1。
	则循环终止条件为j<i（j<=i-1，循环次数为i-1 - 1 + 1 = i-1）
	由于p指向的是第j个元素，所以while循环中循环条件为判断p的值是否为空，
	不空向后移动，找到第i个元素。
	*/
	while(p && j<i){
		p = p->next;
		++j;
	}
	/*
	一、上述循环体如果被执行了最后退出了有两种情况
	1.p的值为空；此时说明没有找到第i个元素，所给的i值大于链表的表长度。
	2.j的值等于i了，此时说明找到了第i个元素。
	二、上顺循环体如果没有被执行则也有两种情况。
	1.p的值为空，则说明此链表为空表。
	2.j的值大于或等于i，当j的值大于i时，这说明i的值是小于1的，则说明i的值不合法。
		当j的值等于i时候（此时i等于1），相当于（一）中的第2点，说明找到了第i个元素。
	*/
	
	
	/*
	下列的if语句如果执行了，这说明了第i个值不存在。第i个值不存在有两种情况：
	1.i的值不合法：则i的值大于链表长度时，p会为空。i的值小于1时，j>i;
	2.链表为空，则p为空。但是一般进行查找操作时，链表一般不为空。
	如果上述任一情况发生时，则会执行此if语句，这时会退出此函数。
	*/
	if(!P || j>i)
		return ERROR;
		
	/*
	当函数执行将要执行下一条语句时，说明第i个值是存在的。
	则现在p指向的就是第i个元素，现在就可以进行相应的操作了。
	*/
	e = p->data;
	return OK;
}





/*
心得：在编写循环结构代码时候，如过循环的次数不确定，那么此循环结构
的重点是结束条件的确定。如果循环的次数是确定的，那么此循环结构的关键是，循环变量的初始值和终末值的确定。
在确定结尾时候，注意循环结束条件是">","<"还是">=","<=">
一般情况下用包含等于的判断条件好看出循环体的执行次数。
这时，循环体执行的次数为n-i+1(假设循环变量的初始值为i，终末值为n)
考虑问题一定要全面。
*/
